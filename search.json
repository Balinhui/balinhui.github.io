[{"title":"window","url":"/2025/04/19/window/","content":"\n一个小窗口。\n\n```java\npackage org.demo;\n\nimport com.sun.jna.Native;\nimport com.sun.jna.platform.win32.WinDef.HWND;\nimport com.sun.jna.ptr.IntByReference;\nimport com.sun.jna.win32.StdCallLibrary;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\npublic class AcrylicEffectJFrame extends JFrame {\n    /**\n     * 储存窗口的句柄，在窗口显示可见时获取值\n     * Stores the handle of the window, and gets the value when the window is visible\n     */\n    private static HWND hWnd;\n\n    /**\n     * 窗口的标题栏，负责拖动和存放<code>Title</code>和三个控制按钮\n     * The title bar of the window, which is responsible for dragging and storing the <code>Title</code> and the three control buttons\n     */\n    private final JLabel titleBar = createTitleBar();\n    private final JButton close = createControlButton(\"\\uE653\", 1, LANGUAGE_SUPPORT.close, e -> exit());\n    private final JButton maximize = createControlButton(\"\\uE655\",2, LANGUAGE_SUPPORT.maximize, e -> toggleMaximize());\n    private final JButton minimize = createControlButton(\"\\uE654\", 3, LANGUAGE_SUPPORT.minimize, e -> mix());\n\n    /**\n     * 窗口的根面板\n     * The root panel of the window\n     */\n    private final JPanel ContentPane = new JPanel() {\n        @Override\n        protected void paintComponent(Graphics g) {\n            super.paintComponent(g);\n            g.setColor(new Color(255, 255, 255, 1));\n            g.fillRect(0, 0, getWidth(), getHeight());\n        }\n    };\n\n    /**\n     * 记录窗口是否在焦点的值\n     * The value of recording whether the window is in focus\n     */\n    private boolean onFocus = true;\n\n    /**\n     * 记录窗口是否最大化的值\n     * The value of recording whether the window is maximized\n     */\n    private boolean onMax = false;\n\n    /**\n     * 记录鼠标位置，拖动窗口\n     * Record the mouse position, use to drag the window\n     */\n    private Point dragStart;\n\n    /**\n     * 记录窗口大小\n     * Record the size of the window\n     */\n    private Rectangle startBounds;\n\n    /**\n     * 检测边框的灵敏度（像素）\n     * Detect the sensitivity of the bezel(pixel)\n     */\n    private final int resizeMargin = 8;\n\n    /**\n     * 记录窗口是否能改变大小的值\n     * Records whether the window can change the value of the size\n     */\n    protected boolean resizable = true;\n\n    /**\n     * 记录标题栏高度的值（像素）\n     */\n    private int titlebarHeight = 29;\n\n    private int defaultCloseOperation = HIDE_ON_CLOSE;\n\n    /**\n     * 记录按下的鼠标按键\n     */\n    private int ButtonNum = MouseEvent.NOBUTTON;\n\n    private static final Color notOnFocus = new Color(141, 142, 142);\n\n    static {\n        System.setProperty(\"jna.encoding\", \"UTF-8\");\n        if (System.getProperty(\"user.language\").equals(\"en\")) {\n            LANGUAGE_SUPPORT.initForEnglish();\n        } else if (System.getProperty(\"user.language\").equals(\"zh\")) {\n            LANGUAGE_SUPPORT.initForChinese();\n        }\n        if (!System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n            throw new RuntimeException(LANGUAGE_SUPPORT.systemDoesNotSupport);\n        }\n    }\n\n    public static class LANGUAGE_SUPPORT {\n        static String close;\n\n        static String maximize;\n\n        static String minimize;\n\n        static String restore;\n\n        static String systemDoesNotSupport;\n\n        static String titlebarSettingIncorrect;\n\n        static String hWndGet;\n\n        static String windowFlash;\n\n        static String showWindow;\n\n        public static void initForChinese() {\n            close = \"关闭\";\n            maximize = \"最大化\";\n            minimize = \"最小化\";\n            restore = \"向下还原\";\n            systemDoesNotSupport = \"系统不支持\";\n            titlebarSettingIncorrect = \"标题栏高度设置错误, 应为15 ~ 44之间\";\n            hWndGet = \"窗口句柄未获取\";\n            windowFlash = \"窗口闪烁失败\";\n            showWindow = \"show失败\";\n        }\n\n        public static void initForEnglish() {\n            close = \"close\";\n            maximize = \"maximize\";\n            minimize = \"minimize\";\n            restore = \"restore\";\n            systemDoesNotSupport = \"The system does not support it\";\n            titlebarSettingIncorrect = \"Title bar height setting is incorrect, it should be between 15 and 44\";\n            hWndGet = \"The hWnd is not retrieved\";\n            windowFlash = \"Window flashing failed\";\n            showWindow = \"Showing window failed\";\n        }\n    }\n\n    //见https://learn.microsoft.com/zh-cn/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n    public interface DWMWINDOWATTRIBUTE {\n        int DWMWA_SYSTEMBACKDROP_TYPE = 38;  // Windows 11 新增的云母材质属性\n\n        int DWMWA_WINDOW_CORNER_PREFERENCE = 33; //设置圆角\n    }\n\n    //见https://learn.microsoft.com/zh-cn/windows/win32/api/dwmapi/ne-dwmapi-dwm_systembackdrop_type\n    public interface DWM_SYSTEMBACKDROP_TYPE {\n        @Deprecated\n        int DWMSBT_AUTO = 0;               // 系统默认\n\n        @Deprecated\n        int DWMSBT_NONE = 1;               // 无材质\n\n        @Deprecated\n        int DWMSBT_MAINWINDOW = 2;         // 云母材质（主窗口）\n\n        int DWMSBT_TRANSIENTWINDOW = 3;    // 亚克力材质（弹出窗口）\n\n        @Deprecated\n        int DWMSBT_TABBEDWINDOW = 4;       // 标签页材质\n    }\n\n    //见https://learn.microsoft.com/zh-cn/windows/win32/api/dwmapi/ne-dwmapi-dwm_window_corner_preference\n    public interface DWM_WINDOW_CORNER_PREFERENCE {\n        @Deprecated\n        int DWMWCP_DEFAULT = 0;            //默认边角\n\n        @Deprecated\n        int DWMWCP_DONOTROUND = 1;         //禁止圆角\n        int DWMWCP_ROUND = 2;              //大圆角\n\n        @Deprecated\n        int DWMWCP_ROUNDSMALL = 3;         //小圆角\n    }\n\n    public interface SHOW_WINDOW {\n        int SW_HIDE = 0;          //隐藏窗口并激活另一个窗口\n\n        int SW_SHOWNORMAL = 1;    //激活并显示窗口。 如果窗口最小化、最大化或排列，系统会将其还原到其原始大小和位置。 应用程序应在首次显示窗口时指定此标志\n        int SW_NORMAL = 1;  \t  //上同\n\n        int SW_SHOWMINIMIZED = 2; //激活窗口并将其显示为最小化窗口。\n\n        int SW_SHOWMAXIMIZED = 3; //激活窗口并显示最大化的窗口。\n        int SW_MAXIMIZE = 3;\t  //上同\n\n        int SW_SHOWNOACTIVATE = 4;//以最近的大小和位置显示窗口。 此值类似于 SW_SHOWNORMAL，只是窗口未激活。\n\n        int SW_SHOW = 5;\t      //激活窗口并以当前大小和位置显示窗口。\n\n        int SW_MINIMIZE = 6;\t  //最小化指定的窗口，并按 Z 顺序激活下一个顶级窗口。\n\n        int SW_SHOWMINNOACTIVE = 7;//将窗口显示为最小化窗口。 此值类似于 SW_SHOWMINIMIZED，但窗口未激活。\n\n        int SW_SHOWNA = 8;\t      //以当前大小和位置显示窗口。 此值类似于 SW_SHOW，只是窗口未激活。\n\n        int SW_RESTORE = 9;\t      //激活并显示窗口。 如果窗口最小化、最大化或排列，系统会将其还原到其原始大小和位置。 还原最小化窗口时，应用程序应指定此标志。\n\n        int SW_SHOWDEFAULT = 10;  //根据启动应用程序的程序传递给 CreateProcess 函数的 STARTUPINFO 结构中指定的SW_值设置显示状态。\n\n        int SW_FORCEMINIMIZE = 11;//最小化窗口，即使拥有窗口的线程没有响应。 仅当最小化不同线程的窗口时，才应使用此标志。\n\n    }\n\n    public interface DwmApi extends StdCallLibrary {\n        DwmApi INSTANCE = Native.load(\"dwmapi\", DwmApi.class);\n\n        //见https://learn.microsoft.com/zh-cn/windows/win32/api/dwmapi/nf-dwmapi-dwmsetwindowattribute\n        void DwmSetWindowAttribute(HWND hWnd, int dwAttribute, IntByReference pvAttribute, int cbAttribute);\n    }\n\n    public interface User32 extends StdCallLibrary {\n        User32 INSTANCE = Native.load(\"user32\", User32.class);\n\n        //见https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-flashwindow\n        boolean FlashWindow(HWND hWnd, boolean bInvert);\n\n        //https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-showwindow\n        boolean ShowWindow(HWND hWnd, int nCmdShow);\n    }\n\n    private void applyAcrylicEffect() {\n        if (hWnd == null) {\n            throw new RuntimeException(LANGUAGE_SUPPORT.hWndGet);\n        }\n\n        IntByReference effectRef = new IntByReference(DWM_SYSTEMBACKDROP_TYPE.DWMSBT_TRANSIENTWINDOW);\n\n        IntByReference roundRef = new IntByReference(DWM_WINDOW_CORNER_PREFERENCE.DWMWCP_ROUND);\n\n        //启用背景效果\n        DwmApi.INSTANCE.DwmSetWindowAttribute(hWnd, DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE, effectRef, 4);\n\n        //启用圆角\n        DwmApi.INSTANCE.DwmSetWindowAttribute(hWnd, DWMWINDOWATTRIBUTE.DWMWA_WINDOW_CORNER_PREFERENCE, roundRef, 4);\n    }\n\n    /**\n     * 无参构造，将要初始化窗口\n     * There is no parameter construction, and will initialize the window\n     */\n    public AcrylicEffectJFrame() {\n        initializeUI();\n    }\n\n    /**\n     * 初始化窗口时为窗口命名\n     * Name the window when it is initialized\n     * @param title 窗口标题 The title of the window\n     */\n    public AcrylicEffectJFrame(String title) {\n        this.setTitle(title);\n        initializeUI();\n    }\n\n    public AcrylicEffectJFrame(GraphicsConfiguration gc) {\n        super(gc);\n        initializeUI();\n    }\n\n    public AcrylicEffectJFrame(String title, GraphicsConfiguration gc) {\n        super(gc);\n        this.setTitle(title);\n        initializeUI();\n    }\n\n    /**\n     * 初始化窗口，为窗口去掉装饰，设置透明背景，添加三个控制按钮，添加监听\n     * Initialize the window, remove the decoration from the window,\n     * set the transparent background, add three control buttons, and add listeners\n     */\n    private void initializeUI() {\n        setUndecorated(true);\n        setBackground(new Color(0, 0, 0, 0));\n        //窗口最大最小化 max and minimize\n        addWindowStateListener(e -> {\n            if (!onMax) {\n                onMax = true;\n                maximize.setText(\"\\uE656\");\n                maximize.setToolTipText(LANGUAGE_SUPPORT.restore);\n            } else {\n                onMax = false;\n                maximize.setText(\"\\uE655\");\n                maximize.setToolTipText(LANGUAGE_SUPPORT.maximize);\n            }\n            addControlButton();\n            addTitleBar();\n        });\n\n        addWindowFocusListener(new WindowFocusListener() {\n            @Override\n            public void windowGainedFocus(WindowEvent e) {\n                onFocus = true;\n                titleBar.setForeground(Color.BLACK);\n                close.setForeground(Color.BLACK);\n                maximize.setForeground(Color.BLACK);\n                minimize.setForeground(Color.BLACK);\n            }\n\n            @Override\n            public void windowLostFocus(WindowEvent e) {\n                onFocus = false;\n                titleBar.setForeground(notOnFocus);\n                close.setForeground(notOnFocus);\n                maximize.setForeground(notOnFocus);\n                minimize.setForeground(notOnFocus);\n            }\n        });\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                ButtonNum = e.getButton();\n                startBounds = getBounds();\n                dragStart = e.getLocationOnScreen();\n            }\n        });\n\n        addMouseMotionListener(new MouseAdapter() {\n            // 记录鼠标的位置 Record the position of the mouse\n            int edge = -1;\n\n            @Override\n            public void mouseMoved(MouseEvent e) {\n                if (!resizable) return;\n\n                updateCursor(e.getPoint(), getSize());\n                edge = getEdgeType(e.getPoint(), getSize());\n            }\n\n            @Override\n            public void mouseDragged(MouseEvent e) {\n                if (edge == -1) return;\n                if (startBounds ==null) return;\n                if (ButtonNum != MouseEvent.BUTTON1) return;\n\n                Point current = e.getLocationOnScreen();\n                int dx = current.x - dragStart.x;\n                int dy = current.y - dragStart.y;\n\n                // 根据鼠标位置判断调整方向 Adjust the direction according to the position of the mouse\n                adjustWindowBounds(edge, dx, dy);\n                addControlButton();\n                addTitleBar();\n            }\n        });\n\n        ContentPane.setOpaque(false);\n        setContentPane(ContentPane);\n    }\n\n    private JButton createControlButton(String text, int style, String tip, ActionListener action) {\n        JButton button = new JButton(text);\n        button.setFont(new Font(\"Segoe Fluent Icons\", Font.PLAIN, 10));\n        button.setForeground(Color.BLACK);\n        button.setBackground((style == 1) ? new Color(186, 41, 27) : new Color(219, 219, 219));\n        button.setContentAreaFilled(false);\n        button.setBorderPainted(false);\n        button.setFocusPainted(false);\n        button.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n        button.addActionListener(action);\n        button.setToolTipText(tip);\n\n        // 悬停效果\n        button.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseEntered(MouseEvent e) {\n                button.setContentAreaFilled(true);\n                if (style == 1) {\n                    button.setForeground(Color.WHITE);\n                }\n            }\n\n            @Override\n            public void mouseExited(MouseEvent e) {\n                button.setContentAreaFilled(false);\n                if (style == 1) {\n                    if (onFocus) {\n                        button.setForeground(Color.BLACK);\n                    } else {\n                        button.setForeground(notOnFocus);\n                    }\n                }\n            }\n        });\n        return button;\n    }\n\n    private JLabel createTitleBar() {\n        JLabel label = new JLabel();\n        label.setFont(new Font(\"微软雅黑\", Font.PLAIN, 14));\n        label.setForeground(Color.BLACK);\n        label.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                ButtonNum = e.getButton();\n                dragStart = e.getPoint();\n            }\n\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                if (e.getClickCount() == 2) toggleMaximize();\n            }\n        });\n        label.addMouseMotionListener(new MouseMotionAdapter() {\n            @Override\n            public void mouseDragged(MouseEvent e) {\n                if (ButtonNum != MouseEvent.BUTTON1) return;\n                if (onMax) toggleMaximize();\n\n                Point current = e.getLocationOnScreen();\n                setLocation(current.x - dragStart.x, current.y - dragStart.y);\n            }\n        });\n        return label;\n    }\n\n    private void addControlButton() {\n        close.setBounds(getWidth() - 47, 0, 47, titlebarHeight);\n        maximize.setBounds(getWidth() - 2 * 47, 0, 47, titlebarHeight);\n        minimize.setBounds(getWidth() - 3 * 47, 0, 47, titlebarHeight);\n        ContentPane.add(close);\n        ContentPane.add(maximize);\n        ContentPane.add(minimize);\n    }\n\n    private void addTitleBar() {\n        titleBar.setBounds(8, 0, getWidth() - 149, titlebarHeight);\n        ContentPane.add(titleBar);\n    }\n\n    private void mix() {\n        setExtendedState(ICONIFIED);\n    }\n\n    private void toggleMaximize() {\n        if ((getExtendedState() & MAXIMIZED_BOTH) == 0) {\n            setExtendedState(MAXIMIZED_BOTH);\n        } else {\n            setExtendedState(NORMAL);\n        }\n    }\n\n    private void exit() {\n        if (defaultCloseOperation == EXIT_ON_CLOSE) {\n            System.exit(0);\n        } else if (defaultCloseOperation == DISPOSE_ON_CLOSE) {\n            dispose();\n        } else if (defaultCloseOperation == HIDE_ON_CLOSE) {\n            //hide window\n            showWindow(SHOW_WINDOW.SW_HIDE);\n        }\n    }\n\n    /**\n     * 更新鼠标样式\n     * Update mouse styles\n     * @param mousePos 鼠标位置 Mouse position\n     * @param size 窗口大小 Window size\n     */\n    private void updateCursor(Point mousePos, Dimension size) {\n        int edgeType = getEdgeType(mousePos, size);\n        switch (edgeType) {\n            case Cursor.N_RESIZE_CURSOR:\n            case Cursor.S_RESIZE_CURSOR:\n                setCursor(Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR));\n                break;\n            case Cursor.E_RESIZE_CURSOR:\n            case Cursor.W_RESIZE_CURSOR:\n                setCursor(Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR));\n                break;\n            case Cursor.NE_RESIZE_CURSOR:\n            case Cursor.SW_RESIZE_CURSOR:\n                setCursor(Cursor.getPredefinedCursor(Cursor.NE_RESIZE_CURSOR));\n                break;\n            case Cursor.NW_RESIZE_CURSOR:\n            case Cursor.SE_RESIZE_CURSOR:\n                setCursor(Cursor.getPredefinedCursor(Cursor.NW_RESIZE_CURSOR));\n                break;\n            default:\n                setCursor(Cursor.getDefaultCursor());\n        }\n    }\n\n    /**\n     * 判断鼠标位于哪个边缘或角落\n     * Determine which edge or corner the mouse is on\n     * @param mousePos 鼠标位置 Mouse position\n     * @param size 窗口大小 Window size\n     * @return 鼠标位于边框位置的值 The value of the mouse at the position of the border\n     */\n    private int getEdgeType(Point mousePos, Dimension size) {\n        int x = mousePos.x;\n        int y = mousePos.y;\n        int width = size.width;\n        int height = size.height;\n\n        boolean isNorth = y < resizeMargin;\n        boolean isSouth = y > height - resizeMargin;\n        boolean isWest = x < resizeMargin;\n        boolean isEast = x > width - resizeMargin;\n\n        if (isNorth && isWest) return Cursor.NW_RESIZE_CURSOR;\n        if (isNorth && isEast) return Cursor.NE_RESIZE_CURSOR;\n        if (isSouth && isWest) return Cursor.SW_RESIZE_CURSOR;\n        if (isSouth && isEast) return Cursor.SE_RESIZE_CURSOR;\n        if (isNorth) return Cursor.N_RESIZE_CURSOR;\n        if (isSouth) return Cursor.S_RESIZE_CURSOR;\n        if (isWest) return Cursor.W_RESIZE_CURSOR;\n        if (isEast) return Cursor.E_RESIZE_CURSOR;\n\n        return -1; // 不在边缘\n    }\n\n    /**\n     * 根据方向调整窗口尺寸\n     * Adjust the window size according to the orientation\n     * @param edgeType 鼠标位于边框位置的值 The value of the mouse at the position of the border\n     * @param dx 鼠标在x轴上的移动 Movement of the mouse on the x-axis\n     * @param dy 鼠标在y轴上的移动 Movement of the mouse on the y-axis\n     */\n    private void adjustWindowBounds(int edgeType, int dx, int dy) {\n        Rectangle bounds = new Rectangle(startBounds);\n        switch (edgeType) {\n            case Cursor.N_RESIZE_CURSOR:\n                bounds.y += dy;\n                bounds.height -= dy;\n                break;\n            case Cursor.S_RESIZE_CURSOR:\n                bounds.height += dy;\n                break;\n            case Cursor.W_RESIZE_CURSOR:\n                bounds.x += dx;\n                bounds.width -= dx;\n                break;\n            case Cursor.E_RESIZE_CURSOR:\n                bounds.width += dx;\n                break;\n            case Cursor.NW_RESIZE_CURSOR:\n                bounds.x += dx;\n                bounds.width -= dx;\n                bounds.y += dy;\n                bounds.height -= dy;\n                break;\n            case Cursor.NE_RESIZE_CURSOR:\n                bounds.width += dx;\n                bounds.y += dy;\n                bounds.height -= dy;\n                break;\n            case Cursor.SW_RESIZE_CURSOR:\n                bounds.x += dx;\n                bounds.width -= dx;\n                bounds.height += dy;\n                break;\n            case Cursor.SE_RESIZE_CURSOR:\n                bounds.width += dx;\n                bounds.height += dy;\n                break;\n            default:\n                return;\n        }\n\n        // 设置最小窗口尺寸 Sets the minimum window size\n        if (bounds.width < 200) bounds.width = 200;\n        if (bounds.height < 200) bounds.height = 200;\n\n        setBounds(bounds);\n    }\n\n    /**\n     * 使用<code>SwingUtilities.invokeLater</code>来确保应用效果代码在事件分派线程中执行\n     * Use <code>SwingUtilities.invokeLater</code> to ensure that the app effect\n     * code is executed in the event dispatch thread\n     */\n    private void addAcrylic() {\n        EventQueue.invokeLater(this::applyAcrylicEffect);\n    }\n\n    /**\n     * 设置标题栏的高度，输入的值的范围为 15 ~ 44，需要在<code>setSize</code>和<code>setVisible</code>之前设置。\n     * @param height 标题栏的高度\n     */\n    public void setTitlebarHeight(int height) {\n        if (15 <= height && 44 >= height) {\n            this.titlebarHeight = height;\n        } else {\n            throw new RuntimeException(LANGUAGE_SUPPORT.titlebarSettingIncorrect);\n        }\n    }\n\n    /**\n     * 获取标题栏高度\n     * @return 标题栏高度\n     */\n    public int getTitlebarHeight() {\n        return this.titlebarHeight;\n    }\n\n    public void flashWindow(boolean bInvent) {\n        if (hWnd == null) {\n            throw new RuntimeException(LANGUAGE_SUPPORT.hWndGet);\n        }\n        boolean state = User32.INSTANCE.FlashWindow(hWnd, bInvent);\n        if (!state && bInvent) {\n            System.err.println(LANGUAGE_SUPPORT.windowFlash);\n        }\n    }\n\n    private void showWindow(int nCmdShow) {\n        if (hWnd == null) {\n            throw new RuntimeException(LANGUAGE_SUPPORT.hWndGet);\n        }\n        boolean state = User32.INSTANCE.ShowWindow(hWnd, nCmdShow);\n        if (!state) {\n            System.err.println(LANGUAGE_SUPPORT.showWindow);\n        }\n    }\n\n    @Override\n    public void setVisible(boolean visible) {\n        super.setVisible(visible);\n        if (!onFocus) {\n            flashWindow(true);\n        }\n    }\n\n    /**\n     * 窗口监听器，在确保窗口已经创建好后为其添加组件以及获取句柄，并为其启用效果\n     * Window listener, add components and get handles to the window after\n     * making sure it's already created, and enable effects for it\n     */\n    @Override\n    public void addNotify() {\n        super.addNotify();\n        addControlButton();\n        addTitleBar();\n        hWnd = new HWND(Native.getComponentPointer(this));\n        addAcrylic();\n    }\n\n    @Override\n    public JPanel getContentPane() {\n        return ContentPane;\n    }\n\n    @Override\n    public void setTitle(String title) {\n        super.setTitle(title);\n        this.titleBar.setText(title);\n    }\n\n    /**\n     * 防止修改<code>undecorated</code>参数\n     * Prevent the <code>undecorated</code> parameter from being modified\n     * @param undecorated {@code true} if no frame decorations are to be\n     *         enabled; {@code false} if frame decorations are to be enabled\n     *\n     */\n    @Override\n    public void setUndecorated(boolean undecorated) {\n        super.setUndecorated(true);\n    }\n\n    /**\n     * 禁止改变窗口大小时，禁用<code>max</code>按钮\n     * When disabling the change the size of window, disable the <code>max</code> button\n     * @param resizable   {@code true} if this frame is resizable;\n     *                       {@code false} otherwise.\n     */\n    @Override\n    public void setResizable(boolean resizable) {\n        super.setResizable(resizable);\n        this.resizable = resizable;\n        maximize.setEnabled(resizable);\n    }\n\n    /**\n     * <code>height + 28</code>是为了给标题栏留出位置\n     * <code>height + 28</code> is to make room for the title bar\n     * @param width the new width of this component in pixels\n     * @param height the new height of this component in pixels\n     */\n    @Override\n    public void setSize(int width, int height) {\n        super.setSize(width, height + titlebarHeight);\n    }\n\n    @Override\n    public void setDefaultCloseOperation(int operation) {\n        super.setDefaultCloseOperation(operation);\n        defaultCloseOperation = operation;\n    }\n}\n\n\n```\n","tags":["windows"]},{"title":"Hello World","url":"/2025/01/20/test/","content":"# 如何用Java写Hello World\njava作为一款热门的语言，掌握如何用它来写Hello World是非常重要的<br>\n接下来就让我来演示一下\n> Hello World\n> ```java\n> public class HelloWorld {\n>   public static void main(String[] args) {\n>       System.out.println(\"Hello World\");\n>   }\n> }\n> ```\n# 完成！\n在上面的例子中，我们新建了一个HelloWorld类，并在主方法中打印了`Hello World`<br>\n怎么样？简单吧，~~接下来就来开发一个安卓应用吧~~\n"},{"title":"math","url":"/2025/01/20/数学/","content":"\n# 来写数学公式\n> $$G = mg$$\n\n> $$v = s/t$$\n\n> $$W = F/S$$\n\n> $$p = W/t$$"},{"title":"如何使用Markdown","url":"/2024/12/09/如何使用Markdown/","content":"\n用于自己以后写Markdown\n\n# 标题\n用# （后面要有空格）来表示\n```Mackdown\n    # 一级标题\n    ## 二级标题\n    ### 三级标题\n    #### 四级标题\n    ##### 五级标题\n    ###### 六级标题\n```\n\n# 字体\n## 斜体\n`*这是斜体*` *这是斜体*\n\n`_这是斜体_` _这是斜体_\n\n## 粗体\n`**这是粗体**` **这是粗体**\n\n`__这是粗体__` __这是粗体__\n\n## 粗斜体\n`***这是粗斜体***` ***这是粗斜体***\n\n`___这是粗斜体___` ___这是粗斜体___\n\n# 换行\n1. 直接在一句话后敲两个空格\n2. 两句话之间加一个空行\n3. 如果你在编辑的时候，想让一行文字在显示的时候换行，就在中间加`<br>`\n\n# 引用\n用`>`来表示引用，后面的空格可有可无，一行空格来结束引用\n\n```Markdown\n    > 这是一个引用\n    >> 这是一个引用中的引用\n    >>> 这是一个引用中的引用中的引用\n```\n\n# 链接\n```Markdown\n    [链接名](链接)\n    或\n    <链接>\n\n    [balinhui](https://balinhui.github.io)\n    或\n    <https://balinhui.github.io>\n```\n\n# 图片\n```Markdown\n    ![图片描述，可写可不写，但是中括号要有](图片链接，本地或URL#pic_center空格=长x宽)\n\n    ![balinhui](https://raw.githubusercontent.com/Balinhui/balinhui.github.io/refs/heads/main/covers/cover.webp#pic_center =200x100)\n```\n\n# 列表\n## 有序列表\n数字后加`.`再加空格\n\n## 无序列表\n用`*`,`+`,`-`,再加空格\n\n\n```Markdown\n    * 无序列表 1\n    + 无序列表 2\n    - 无序列表 3\n\n    1. 有序列表 1\n    2. 有序列表 2\n    3. 有序列表 3\n```\n控制层级\n```Markdown\n    + 无序列表 1\n    + 无序列表 2\n\t    + 无序列表 2.1\n\t    + 无序列表 2.2\n\n    1. 有序列表 1\n\t    1.1 有序列表 1.1\n    2. 有序列表 2\n\t    2.1 有序列表2.1\n```\n\n# 分割线\n用-或*，注意分割线上面要空格\n\n```Markdown\n    分割线：\n\n    ---\n    ***\n    - - -\n    * * *\n```\n\n# 删除线\n在要删除的文字左右两边加上`~~`\n\n```Markdown\n    ~~要被删除的文字~~\n```\n\n# 下划线\n\n在要下划线的文字左右两边加上`<u>文本</u>`\n\n```Markdown\n    <u>要添加下划线的文本</u>\n```\n\n# 代码块\n## 一行代码\n将代码前后用`括起来\n\n```Markdown\n    `Hello` World\n```\n\n## 一块代码\n要在代码前后用三个`，并在前三个后写下语言类型\n```Markdown\n    ```java\n        public class HelloWorld {\n            public static void main(String[] args) {\n                System.out.println(\"Hello World\");\n            }\n        }\n    三个`\n```\n\n# 脚注\n对文本进行标注\n```Markdown\n    Mackdown[^1],java[^2]\n    [^1] Markdown\n    [^2] java\n```\n\nMackdown[^1]\n[^1] Markdown\n\n# 未完待续","tags":["markdown"]},{"title":"移除C盘以外的Program_Files","url":"/2024/12/08/移除C盘以外的Program-Files/","content":"\n每当我在设置Xbox安装路径时，或者~~不小心~~更改了Microsoft Store中的应用的安装路径时，对应的盘下总会生成Program Files文件夹，而且还删不掉。我已知这个文件没用，又想把它删掉，那该怎么办呢？\n# 解决方法\n直接删除是没有用的，重启后还会回来<br>\n\n## 获取所有卷信息\n可以打开PowerShell，以管理员身份运行，使用命令`Get-AppxVolume`查看WindowsApps挂载在哪些盘上\n```PowerShell\n    PS C:\\Windows\\System32> Get-AppxVolume\n```\n此时，除了C盘，还看到有其他盘挂载了WindowsApps\n\n## 删除不用的卷\n使用命令`Remove-AppxVolume -Volume`后面加上空格和前面的ID`{d22g2f23ft-sdgay-26fg62-32dawf}`或盘符`D:\\`\n```PowerShell\n    PS C:\\Windows\\System32> Remove-AppxVolume -Volume D:\\\n```\n回车后用`Get-AppxVolume`命令再次查看<br>\n只剩C盘后就说明成功\n\n之后就是更改文件夹属性，然后删除就行了","tags":["windows"]},{"title":"Hello World","url":"/2013/12/24/hello-world/","content":"\nWelcome to [Hexo](http://zespia.tw/hexo)! This is your very first post. Check [documentation](http://zespia.tw/hexo/docs) to learn how to use.\n"}]